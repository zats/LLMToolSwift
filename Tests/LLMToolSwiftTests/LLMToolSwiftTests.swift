import SwiftSyntax
import Foundation
import SwiftSyntaxBuilder
import SwiftSyntaxMacros
import SwiftSyntaxMacrosTestSupport
import XCTest
import LLMToolSwift
@_spi(Schema) import LLMToolSwift
import LLMToolOpenAI



struct MultipleToolsDispatcher {
    @LLMTool
    /**
     Summary line.

     - Parameter bar: your typical bar.
     */
    func foo(bar: String) {}

    @LLMTool
    /**
     Summary line.

     - Parameter pkao: your typical pkao.
     */
    func baz(pkao: Int) {}
}

// File-scope demo types for runtime macro expansion
// Runtime doc-block demo to validate real code (not string expansion)
struct DocRuntimeDemo {
    @LLMTool
    /**
     Summary line.

     - Parameter city: City name.
     */
    func f(city: String) {}
}

@LLMTools
struct Demo {
    enum E: String, CaseIterable { case a, b }
    /// Hi
    /// - Parameter name: Person name
    @LLMTool
    func hi(name: String) -> String { "Hi, \(name)" }
    /// Flag
    /// - Parameter on: Toggle value
    @LLMTool
    func flag(on: Bool) { _ = on }
}

// (llmTools and dispatcher generated by @LLMTools on the type)

// Additional demo to validate NSNull handling
@LLMTools
struct NullDemo {
    @LLMTool
    /// Test optional parameters become nil when NSNull is provided
    func optionalParams(a: String?, b: Int?) -> String {
        let aStr = a ?? "nil"
        let bStr = b.map(String.init) ?? "nil"
        return "\(aStr)-\(bStr)"
    }

    @LLMTool
    /// Test required parameter error when NSNull is provided
    func requiredParam(a: String) -> String { a }
}

// File-scope demo for filtering repository behavior
@LLMTools
struct FilterDemo {
    @LLMTool
    /// Hello
    /// - Parameter name: Name
    func hello(name: String) -> String { "Hi, \(name)" }
    @LLMTool
    /// Add
    /// - Parameter a: a
    /// - Parameter b: b
    func add(a: Int, b: Int) -> Int { a + b }
    @LLMTool
    /// Multiply
    /// - Parameter a: a
    /// - Parameter b: b
    func mul(a: Int, b: Int) -> Int { a * b }
}

// File-scope demo for static-only tool set
@LLMTools
struct StaticOnlyToolsFS {
    @LLMTool
    static func echo(text: String) -> String { text }
}

// File-scope demo for no-argument tools
@LLMTools
struct NoArgDemo {
    @LLMTool
    /// Ping
    func ping() -> String { "pong" }
}

// File-scope demo for defaulted parameters
@LLMTools
struct DefaultRuntimeDemo {
    @LLMTool
    /// Compose
    /// - Parameter name: Name
    /// - Parameter times: Times
    func compose(name: String = "W", times: Int = 1) -> String { "\(name)-\(times)" }

    @LLMTool
    /// Optional with default
    func option(suffix: String? = "x") -> String { suffix ?? "nil" }
}

// File-scope demo for name override
@LLMTools
struct NameOverrideRuntimeDemo {
    @LLMTool(name: "read_file")
    /// Read file
    func readFile() -> String { "ok" }
}

// Macro implementations build for the host, so the corresponding module is not available when cross-compiling. Cross-compiled tests may still make use of the macro itself in end-to-end tests.
#if canImport(LLMToolSwiftMacros)
import LLMToolSwiftMacros

let testMacros: [String: Macro.Type] = [
    "stringify": StringifyMacro.self,
    "LLMTool": LLMToolMacro.self,
    "LLMTools": LLMToolsMacro.self,
]
#endif

final class LLMToolSwiftTests: XCTestCase {
    func testMacro() throws {
        #if canImport(LLMToolSwiftMacros)
        assertMacroExpansion(
            """
            #stringify(a + b)
            """,
            expandedSource: """
            (a + b, "a + b")
            """,
            macros: testMacros
        )
        #else
        throw XCTSkip("macros are only supported when running tests for the host platform")
        #endif
    }

    func testMacroWithStringLiteral() throws {
        #if canImport(LLMToolSwiftMacros)
        assertMacroExpansion(
            #"""
            #stringify("Hello, \(name)")
            """#,
            expandedSource: #"""
            ("Hello, \(name)", #""Hello, \(name)""#)
            """#,
            macros: testMacros
        )
        #else
        throw XCTSkip("macros are only supported when running tests for the host platform")
        #endif
    }

    func testLLMToolMacro_SimpleStringParam() throws {
        #if canImport(LLMToolSwiftMacros)
        assertMacroExpansion(
            """
            public struct S {
                /// Greeting
                /// - Parameter name: A name.
                @LLMTool
                public func f(name: String) {}
            }
            """,
            expandedSource: """
            public struct S {
                /// Greeting
                /// - Parameter name: A name.
                public func f(name: String) {}

                public static var fLLMTool: LLMTool {
                    LLMTool(
                        function: .init(
                            name: "f",
                            description: "Greeting",
                            parameters: .init(
                                properties: [
                                    "name": .init(
                                        type: "string",
                                        description: "A name.",
                                        enum: nil
                                    )
                                ],
                                required: ["name"]
                            )
                        )
                    )
                }
            }
            """,
            macros: testMacros
        )
        #else
        throw XCTSkip("macros are only supported when running tests for the host platform")
        #endif
    }

    func testLLMToolMacro_DefaultedParams_TreatOptional() throws {
        #if canImport(LLMToolSwiftMacros)
        assertMacroExpansion(
            """
            public struct S {
                /// Greeting
                /// - Parameter name: A name.
                /// - Parameter count: Count.
                @LLMTool
                public func f(name: String = "X", count: Int) {}
            }
            """,
            expandedSource: """
            public struct S {
                /// Greeting
                /// - Parameter name: A name.
                /// - Parameter count: Count.
                public func f(name: String = "X", count: Int) {}

                public static var fLLMTool: LLMTool {
                    LLMTool(
                        function: .init(
                            name: "f",
                            description: "Greeting",
                            parameters: .init(
                                properties: [
                                    "name": .init(
                                        type: "string",
                                        description: "A name.",
                                        enum: nil
                                    ),
                                    "count": .init(
                                        type: "integer",
                                        description: "Count.",
                                        enum: nil
                                    )
                                ],
                                required: ["count"]
                            )
                        )
                    )
                }
            }
            """,
            macros: testMacros
        )
        #else
        throw XCTSkip("macros are only supported when running tests for the host platform")
        #endif
    }

    func testLLMToolMacro_NameOverride_Expansion() throws {
        #if canImport(LLMToolSwiftMacros)
        assertMacroExpansion(
            """
            public struct S {
                /// RF
                @LLMTool(name: "read_file")
                public func readFile() {}
            }
            """,
            expandedSource: """
            public struct S {
                /// RF
                public func readFile() {}

                public static var readFileLLMTool: LLMTool {
                    LLMTool(
                        function: .init(
                            name: "read_file",
                            description: "RF",
                            parameters: .init(
                                properties: [:],
                                required: []
                            )
                        )
                    )
                }
            }
            """,
            macros: testMacros
        )
        #else
        throw XCTSkip("macros are only supported when running tests for the host platform")
        #endif
    }

    func testLLMTools_RuntimeDispatcher() async throws {
        // Validate at runtime using file-scope Demo
        let d = Demo()
        XCTAssertEqual(d.llmTools.count, 2)
        let res = try await d.dispatchLLMTool(named: "hi", arguments: ["name": "Zed"]) as? String
        XCTAssertEqual(res, "Hi, Zed")
        do { _ = try await d.dispatchLLMTool(named: "hi", arguments: [:]); XCTFail("expected error") } catch {}
        do { _ = try await d.dispatchLLMTool(named: "unknown", arguments: [:]); XCTFail("expected error") } catch {}
    }

    func testLLMToolMacro_DocBlockParsing() throws {
        #if canImport(LLMToolSwiftMacros)
        assertMacroExpansion(
            """
            public struct S {
                @LLMTool
                /**
                 Summary line.
                 
                 - Parameter city: City name.
                 */
                public func f(city: String) {}
            }
            """,
            expandedSource: """
            public struct S {
                /**
                 Summary line.
                 
                 - Parameter city: City name.
                 */
                public func f(city: String) {}

                public static var fLLMTool: LLMTool {
                    LLMTool(
                        function: .init(
                            name: "f",
                            description: "Summary line.",
                            parameters: .init(
                                properties: [
                                    "city": .init(
                                        type: "string",
                                        description: "City name.",
                                        enum: nil
                                    )
                                ],
                                required: ["city"]
                            )
                        )
                    )
                }
            }
            """,
            macros: testMacros
        )
        #else
        throw XCTSkip("macros are only supported when running tests for the host platform")
        #endif
    }

    func testLLMTool_DocBlock_Runtime() throws {
        let tool = DocRuntimeDemo.fLLMTool
        XCTAssertEqual(tool.function.name, "f")
        XCTAssertEqual(tool.function.description, "Summary line.")
        XCTAssertEqual(tool.function.parameters.properties["city"]?.description, "City name.")
        XCTAssertEqual(tool.function.parameters.required, ["city"])
    }

    func testLLMTool_FunctionJSON_Shape() throws {
        let toolJSON = DocRuntimeDemo.fLLMTool.jsonString
        // Expect modern shape: no legacy wrapper, with strict and additionalProperties
        XCTAssertFalse(toolJSON.contains("\"type\":\"function\""))
        XCTAssertTrue(toolJSON.contains("\"strict\":true"))
        XCTAssertTrue(toolJSON.contains("\"additionalProperties\":false"))
        // Name should be snake_case of function name 'f' (same)
        XCTAssertTrue(toolJSON.contains("\"name\":\"f\""))
    }

    

    func testNSNullTreatedAsNilAndErrorForRequired() async throws {
        let d = NullDemo()
        // Optional params: NSNull should be treated as nil
        let r1 = try await d.dispatchLLMTool(named: "optionalParams", arguments: ["a": NSNull(), "b": NSNull()]) as? String
        XCTAssertEqual(r1, "nil-nil")
        let r2 = try await d.dispatchLLMTool(named: "optionalParams", arguments: ["a": "X", "b": NSNull()]) as? String
        XCTAssertEqual(r2, "X-nil")
        let r3 = try await d.dispatchLLMTool(named: "optionalParams", arguments: ["a": NSNull(), "b": 5]) as? String
        XCTAssertEqual(r3, "nil-5")

        // Required param: NSNull should be treated as missing
        do {
            _ = try await d.dispatchLLMTool(named: "requiredParam", arguments: ["a": NSNull()])
            XCTFail("expected missingArgument error for NSNull on required param")
        } catch LLMToolCallError.missingArgument(let name) {
            XCTAssertEqual(name, "a")
        } catch {
            XCTFail("unexpected error: \(error)")
        }
    }

    func testLLMTools_Filtering_Runtime() async throws {
        // File-scope annotated types conform to LLMToolsRepository
        let _: any LLMToolsRepository = FilterDemo()

        // Full repo has all three
        XCTAssertEqual(FilterDemo().llmTools.map { $0.function.name }, ["hello", "add", "mul"])

        let base = FilterDemo()
        let mask: FilterDemo.LLMToolFilterSet = [.hello, .add]
        let subset = base.filter(mask)

        // Subset lists only selected tools
        XCTAssertEqual(subset.llmTools.map { $0.function.name }, ["hello", "add"])

        // Allowed tools dispatch
        let r1 = try await subset.dispatchLLMTool(named: "hello", arguments: ["name": "Sam"]) as? String
        XCTAssertEqual(r1, "Hi, Sam")
        let r2 = try await subset.dispatchLLMTool(named: "add", arguments: ["a": 2, "b": 3]) as? Int
        XCTAssertEqual(r2, 5)

        // Disallowed tool throws same not-found error
        do {
            _ = try await subset.dispatchLLMTool(named: "mul", arguments: ["a": 2, "b": 3])
            XCTFail("expected functionNotFound for filtered-out tool")
        } catch LLMToolCallError.functionNotFound(let name) {
            XCTAssertEqual(name, "mul")
        } catch {
            XCTFail("unexpected error: \(error)")
        }
    }

    // Note: We rely on runtime conformance checks rather than exact string
    // matching for the extension emission, to avoid overfitting formatting.

    func testOpenAITool_StrictTrue_Encoding() throws {
        // Build a tool with one required and one optional param
        let params = LLMTool.Parameters(
            properties: [
                "name": .init(type: "string", description: "Full name", enum: nil),
                "title": .init(type: "string", description: "Honorific title", enum: nil)
            ],
            required: ["name"]
        )
        let tool = LLMTool(function: .init(name: "greet", description: "", parameters: params))

        let oaiTool = tool.openAITool(strict: true)
        let data = try JSONEncoder().encode(oaiTool)
        let json = String(data: data, encoding: .utf8) ?? ""
        XCTAssertTrue(json.contains("\"strict\":true"))
        // In strict mode, required should contain all properties
        XCTAssertTrue(json.contains("\"required\":[\"name\",\"title\"]"))
        // Optional field should admit null via union type
        XCTAssertTrue(json.contains("\"type\":[\"string\",\"null\"]"))
        // Parameter descriptions should be present
        XCTAssertTrue(json.contains("\"description\":\"Full name\""))
        XCTAssertTrue(json.contains("\"description\":\"Honorific title\""))
    }

    func testNormalizedSchema_StrictTrue() throws {
        // Build tool with required + optional
        let params = LLMTool.Parameters(
            properties: [
                "name": .init(type: .string, description: "Full name", enum: nil),
                "title": .init(type: .string, description: "Honorific title", enum: nil)
            ],
            required: ["name"]
        )
        let tool = LLMTool(function: .init(name: "greet", description: "", parameters: params))
        let model = tool.normalizedSchema(strict: true)

        // required should contain all keys in strict mode (sorted)
        XCTAssertEqual(model.parameters.required, ["name", "title"]) 
        // name: string
        XCTAssertEqual(model.parameters.properties["name"]?.types, [.string])
        // title: string | null
        XCTAssertEqual(Set(model.parameters.properties["title"]?.types ?? []), Set([.string, .null]))
        // additionalProperties false
        XCTAssertEqual(model.parameters.additionalProperties, false)
    }

    func testNormalizedSchema_ParityWithJSON() throws {
        let params = LLMTool.Parameters(
            properties: [
                "name": .init(type: .string, description: "Full name", enum: nil),
                "title": .init(type: .string, description: "Honorific title", enum: nil)
            ],
            required: ["name"]
        )
        let tool = LLMTool(function: .init(name: "greet", description: "", parameters: params))
        let model = tool.normalizedSchema(strict: true)
        let json = tool.jsonSchema(strict: true)

        // Decode json for property type comparison
        struct Dec: Decodable {
            struct P: Decodable {
                let type: Either
            }
            struct Params: Decodable { let properties: [String: P]; let required: [String]; let additionalProperties: Bool }
            let name: String; let strict: Bool; let parameters: Params
        }
        enum Either: Decodable, Equatable { case one(String), many([String])
            init(from d: Decoder) throws {
                let c = try d.singleValueContainer()
                if let s = try? c.decode(String.self) { self = .one(s) }
                else { self = .many(try c.decode([String].self)) }
            }
        }
        let data = Data(json.utf8)
        let dec = try JSONDecoder().decode(Dec.self, from: data)

        XCTAssertEqual(dec.parameters.required, model.parameters.required)
        for (name, prop) in model.parameters.properties {
            let want = prop.types.map { $0.rawValue }.sorted()
            let got: [String]
            switch dec.parameters.properties[name]?.type {
            case .one(let s): got = [s]
            case .many(let a): got = a
            case .none: XCTFail("missing property: \(name)"); continue
            }
            XCTAssertEqual(got.sorted(), want, "type mismatch for \(name)")
        }
    }

    func testOpenAITool_StrictFalse_Encoding() throws {
        // Build a tool with one required and one optional param
        let params = LLMTool.Parameters(
            properties: [
                "name": .init(type: "string", description: "Full name", enum: nil),
                "title": .init(type: "string", description: "Honorific title", enum: nil)
            ],
            required: ["name"]
        )
        let tool = LLMTool(function: .init(name: "greet", description: "", parameters: params))

        let oaiTool = tool.openAITool(strict: false)
        let data = try JSONEncoder().encode(oaiTool)
        let json = String(data: data, encoding: .utf8) ?? ""
        XCTAssertTrue(json.contains("\"strict\":false"))
        // In non-strict mode, required should contain only the actually required keys
        XCTAssertTrue(json.contains("\"required\":[\"name\"]"))
        // Optional field should NOT admit null via union type
        XCTAssertFalse(json.contains("\"type\":[\"string\",\"null\"]"))
        // Parameter descriptions should be present
        XCTAssertTrue(json.contains("\"description\":\"Full name\""))
        XCTAssertTrue(json.contains("\"description\":\"Honorific title\""))
    }

    func testJSONSchema_StrictTrue() throws {
        let params = LLMTool.Parameters(
            properties: [
                "name": .init(type: "string", description: "Full name", enum: nil),
                "title": .init(type: "string", description: "Honorific title", enum: nil)
            ],
            required: ["name"]
        )
        let tool = LLMTool(function: .init(name: "greet", description: "", parameters: params))
        let json = tool.jsonSchema(strict: true)
        XCTAssertTrue(json.contains("\"type\":\"object\""))
        XCTAssertTrue(json.contains("\"required\":[\"name\",\"title\"]"))
        XCTAssertTrue(json.contains("\"additionalProperties\":false"))
        XCTAssertTrue(json.contains("\"type\":[\"string\",\"null\"]"))
        XCTAssertTrue(json.contains("\"strict\":true"))
        // Parameter descriptions should be present
        XCTAssertTrue(json.contains("\"description\":\"Full name\""))
        XCTAssertTrue(json.contains("\"description\":\"Honorific title\""))
    }

    func testJSONSchema_StrictFalse() throws {
        let params = LLMTool.Parameters(
            properties: [
                "name": .init(type: "string", description: "Full name", enum: nil),
                "title": .init(type: "string", description: "Honorific title", enum: nil)
            ],
            required: ["name"]
        )
        let tool = LLMTool(function: .init(name: "greet", description: "", parameters: params))
        let json = tool.jsonSchema(strict: false)
        XCTAssertTrue(json.contains("\"required\":[\"name\"]"))
        XCTAssertFalse(json.contains("\"type\":[\"string\",\"null\"]"))
        XCTAssertTrue(json.contains("\"strict\":false"))
        // Parameter descriptions should be present
        XCTAssertTrue(json.contains("\"description\":\"Full name\""))
        XCTAssertTrue(json.contains("\"description\":\"Honorific title\""))
    }

    func testJSONSchema_StringVariant() throws {
        let params = LLMTool.Parameters(
            properties: [
                "name": .init(type: "string", description: "Full name", enum: nil),
                "title": .init(type: "string", description: "Honorific title", enum: nil)
            ],
            required: ["name"]
        )
        let tool = LLMTool(function: .init(name: "greet", description: "", parameters: params))
        let json = tool.jsonSchema(strict: true)
        XCTAssertTrue(json.contains("\"required\":[\"name\",\"title\"]"))
        XCTAssertTrue(json.contains("\"strict\":true"))
        XCTAssertTrue(json.contains("\"description\":\"Full name\""))
        XCTAssertTrue(json.contains("\"description\":\"Honorific title\""))
    }

    func testLLMTools_StaticOnly_ConformanceAndDispatch() async throws {
        // Conformance must be satisfied even if all tools are static
        let repo: any LLMToolsRepository = StaticOnlyToolsFS()
        XCTAssertEqual(repo.llmTools.map { $0.function.name }, ["echo"])
        let r = try await repo.dispatchLLMTool(named: "echo", arguments: ["text": "OK"]) as? String
        XCTAssertEqual(r, "OK")
    }

    func testLLMToolMacro_NoParams_Expansion() throws {
        #if canImport(LLMToolSwiftMacros)
        assertMacroExpansion(
            """
            public struct S {
                /// Ping
                @LLMTool
                public func ping() -> String { "pong" }
            }
            """,
            expandedSource: """
            public struct S {
                /// Ping
                public func ping() -> String { "pong" }

                public static var pingLLMTool: LLMTool {
                    LLMTool(
                        function: .init(
                            name: "ping",
                            description: "Ping",
                            parameters: .init(
                                properties: [:],
                                required: []
                            )
                        )
                    )
                }
            }
            """,
            macros: testMacros
        )
        #else
        throw XCTSkip("macros are only supported when running tests for the host platform")
        #endif
    }

    func testNoArgDispatch_Runtime() async throws {
        // No-arg function should dispatch with empty arguments
        let d = NoArgDemo()
        XCTAssertEqual(d.llmTools.map { $0.function.name }, ["ping"])
        // Schema should have empty properties/required
        let tool = d.llmTools[0]
        XCTAssertTrue(tool.function.parameters.properties.isEmpty)
        XCTAssertTrue(tool.function.parameters.required.isEmpty)
        let res = try await d.dispatchLLMTool(named: "ping", arguments: [:]) as? String
        XCTAssertEqual(res, "pong")
    }

    func testDefaults_RuntimeDispatch() async throws {
        let d = DefaultRuntimeDemo()
        // No args -> use defaults
        let r1 = try await d.dispatchLLMTool(named: "compose", arguments: [:]) as? String
        XCTAssertEqual(r1, "W-1")
        // Name provided only
        let r2 = try await d.dispatchLLMTool(named: "compose", arguments: ["name": "A"]) as? String
        XCTAssertEqual(r2, "A-1")
        // Times provided only
        let r3 = try await d.dispatchLLMTool(named: "compose", arguments: ["times": 3]) as? String
        XCTAssertEqual(r3, "W-3")
        // NSNull should be treated as missing and thus use default
        let r4 = try await d.dispatchLLMTool(named: "compose", arguments: ["name": NSNull()]) as? String
        XCTAssertEqual(r4, "W-1")

        // Optional with default value
        let r5 = try await d.dispatchLLMTool(named: "option", arguments: [:]) as? String
        XCTAssertEqual(r5, "x")
        let r6 = try await d.dispatchLLMTool(named: "option", arguments: ["suffix": NSNull()]) as? String
        XCTAssertEqual(r6, "x")
        let r7 = try await d.dispatchLLMTool(named: "option", arguments: ["suffix": "Z"]) as? String
        XCTAssertEqual(r7, "Z")
    }

    func testNameOverride_RuntimeDispatch() async throws {
        let d = NameOverrideRuntimeDemo()
        XCTAssertEqual(d.llmTools.map { $0.function.name }, ["read_file"])
        // Dispatch by overridden name succeeds
        let r = try await d.dispatchLLMTool(named: "read_file", arguments: [:]) as? String
        XCTAssertEqual(r, "ok")
        // Dispatch by original function name should not be found
        do {
            _ = try await d.dispatchLLMTool(named: "readFile", arguments: [:])
            XCTFail("expected functionNotFound for original name")
        } catch LLMToolCallError.functionNotFound(let name) {
            XCTAssertEqual(name, "readFile")
        } catch {
            XCTFail("unexpected error: \(error)")
        }
    }
}
