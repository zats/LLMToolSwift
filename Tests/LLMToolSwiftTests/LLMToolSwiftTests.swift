import SwiftSyntax
import SwiftSyntaxBuilder
import SwiftSyntaxMacros
import SwiftSyntaxMacrosTestSupport
import XCTest
import LLMToolSwift
import LLMToolOpenAI



struct MultipleToolsDispatcher {
    @LLMTool
    /**
     Summary line.

     - Parameter bar: your typical bar.
     */
    func foo(bar: String) {}

    @LLMTool
    /**
     Summary line.

     - Parameter pkao: your typical pkao.
     */
    func baz(pkao: Int) {}
}

// File-scope demo types for runtime macro expansion
// Runtime doc-block demo to validate real code (not string expansion)
struct DocRuntimeDemo {
    @LLMTool
    /**
     Summary line.

     - Parameter city: City name.
     */
    func f(city: String) {}
}

@LLMTools
struct Demo {
    enum E: String, CaseIterable { case a, b }
    /// Hi
    /// - Parameter name: Person name
    @LLMTool
    func hi(name: String) -> String { "Hi, \(name)" }
    /// Flag
    /// - Parameter on: Toggle value
    @LLMTool
    func flag(on: Bool) { _ = on }
}

// (llmTools and dispatcher generated by @LLMTools on the type)

// Macro implementations build for the host, so the corresponding module is not available when cross-compiling. Cross-compiled tests may still make use of the macro itself in end-to-end tests.
#if canImport(LLMToolSwiftMacros)
import LLMToolSwiftMacros

let testMacros: [String: Macro.Type] = [
    "stringify": StringifyMacro.self,
    "LLMTool": LLMToolMacro.self,
    "LLMTools": LLMToolsMacro.self,
    "LLMToolRepository": LLMToolRepositoryMacro.self,
]
#endif

final class LLMToolSwiftTests: XCTestCase {
    func testMacro() throws {
        #if canImport(LLMToolSwiftMacros)
        assertMacroExpansion(
            """
            #stringify(a + b)
            """,
            expandedSource: """
            (a + b, "a + b")
            """,
            macros: testMacros
        )
        #else
        throw XCTSkip("macros are only supported when running tests for the host platform")
        #endif
    }

    func testMacroWithStringLiteral() throws {
        #if canImport(LLMToolSwiftMacros)
        assertMacroExpansion(
            #"""
            #stringify("Hello, \(name)")
            """#,
            expandedSource: #"""
            ("Hello, \(name)", #""Hello, \(name)""#)
            """#,
            macros: testMacros
        )
        #else
        throw XCTSkip("macros are only supported when running tests for the host platform")
        #endif
    }

    func testLLMToolMacro_SimpleStringParam() throws {
        #if canImport(LLMToolSwiftMacros)
        assertMacroExpansion(
            """
            public struct S {
                /// Greeting
                /// - Parameter name: A name.
                @LLMTool
                public func f(name: String) {}
            }
            """,
            expandedSource: """
            public struct S {
                /// Greeting
                /// - Parameter name: A name.
                public func f(name: String) {}

                public static var fLLMTool: LLMTool {
                    LLMTool(
                        function: .init(
                            name: "f",
                            description: "Greeting",
                            parameters: .init(
                                properties: [
                                    "name": .init(
                                        type: "string",
                                        description: "A name.",
                                        enum: nil
                                    )
                                ],
                                required: ["name"]
                            )
                        )
                    )
                }
            }
            """,
            macros: testMacros
        )
        #else
        throw XCTSkip("macros are only supported when running tests for the host platform")
        #endif
    }

    func testLLMTools_RuntimeDispatcher() async throws {
        // Validate at runtime using file-scope Demo
        XCTAssertEqual(Demo.llmTools.count, 2)
        let d = Demo()
        let res = try await d.dispatchLLMTool(named: "hi", arguments: ["name": "Zed"]) as? String
        XCTAssertEqual(res, "Hi, Zed")
        do { _ = try await d.dispatchLLMTool(named: "hi", arguments: [:]); XCTFail("expected error") } catch {}
        do { _ = try await d.dispatchLLMTool(named: "unknown", arguments: [:]); XCTFail("expected error") } catch {}
    }

    func testLLMToolMacro_DocBlockParsing() throws {
        #if canImport(LLMToolSwiftMacros)
        assertMacroExpansion(
            """
            public struct S {
                @LLMTool
                /**
                 Summary line.
                 
                 - Parameter city: City name.
                 */
                public func f(city: String) {}
            }
            """,
            expandedSource: """
            public struct S {
                /**
                 Summary line.
                 
                 - Parameter city: City name.
                 */
                public func f(city: String) {}

                public static var fLLMTool: LLMTool {
                    LLMTool(
                        function: .init(
                            name: "f",
                            description: "Summary line.",
                            parameters: .init(
                                properties: [
                                    "city": .init(
                                        type: "string",
                                        description: "City name.",
                                        enum: nil
                                    )
                                ],
                                required: ["city"]
                            )
                        )
                    )
                }
            }
            """,
            macros: testMacros
        )
        #else
        throw XCTSkip("macros are only supported when running tests for the host platform")
        #endif
    }

    func testLLMTool_DocBlock_Runtime() throws {
        let tool = DocRuntimeDemo.fLLMTool
        XCTAssertEqual(tool.function.name, "f")
        XCTAssertEqual(tool.function.description, "Summary line.")
        XCTAssertEqual(tool.function.parameters.properties["city"]?.description, "City name.")
        XCTAssertEqual(tool.function.parameters.required, ["city"])
    }

    func testLLMTool_FunctionJSON_Shape() throws {
        let toolJSON = DocRuntimeDemo.fLLMTool.jsonString
        // Expect modern shape: no legacy wrapper, with strict and additionalProperties
        XCTAssertFalse(toolJSON.contains("\"type\":\"function\""))
        XCTAssertTrue(toolJSON.contains("\"strict\":true"))
        XCTAssertTrue(toolJSON.contains("\"additionalProperties\":false"))
        // Name should be snake_case of function name 'f' (same)
        XCTAssertTrue(toolJSON.contains("\"name\":\"f\""))
    }

    func testLLMToolRepository_Runtime() async throws {
        @LLMToolRepository
        struct RepoDemo {
            /// Hello
            /// - Parameter name: Name
            func hello(name: String) -> String { "Hi, \(name)" }
            /// Add
            /// - Parameter a: a
            /// - Parameter b: b
            func add(a: Int, b: Int) -> Int { a + b }
            private func hidden() {}
        }
        // Repo should include only functions whose access >= type access (internal)
        XCTAssertEqual(RepoDemo.llmTools.count, 2)
        let demo = RepoDemo()
        let r1 = try await demo.dispatchLLMTool(named: "hello", arguments: ["name": "Ana"]) as? String
        XCTAssertEqual(r1, "Hi, Ana")
        let r2 = try await demo.dispatchLLMTool(named: "add", arguments: ["a": 2, "b": 3]) as? Int
        XCTAssertEqual(r2, 5)
    }

    func testOpenAITool_StrictTrue_Encoding() throws {
        // Build a tool with one required and one optional param
        let params = LLMTool.Parameters(
            properties: [
                "name": .init(type: "string", description: "", enum: nil),
                "title": .init(type: "string", description: "", enum: nil)
            ],
            required: ["name"]
        )
        let tool = LLMTool(function: .init(name: "greet", description: "", parameters: params))

        let oaiTool = tool.openAITool(strict: true)
        let data = try JSONEncoder().encode(oaiTool)
        let json = String(data: data, encoding: .utf8) ?? ""
        XCTAssertTrue(json.contains("\"strict\":true"))
        // In strict mode, required should contain all properties
        XCTAssertTrue(json.contains("\"required\":[\"name\",\"title\"]"))
        // Optional field should admit null via union type
        XCTAssertTrue(json.contains("\"type\":[\"string\",\"null\"]"))
    }

    func testOpenAITool_StrictFalse_Encoding() throws {
        // Build a tool with one required and one optional param
        let params = LLMTool.Parameters(
            properties: [
                "name": .init(type: "string", description: "", enum: nil),
                "title": .init(type: "string", description: "", enum: nil)
            ],
            required: ["name"]
        )
        let tool = LLMTool(function: .init(name: "greet", description: "", parameters: params))

        let oaiTool = tool.openAITool(strict: false)
        let data = try JSONEncoder().encode(oaiTool)
        let json = String(data: data, encoding: .utf8) ?? ""
        XCTAssertTrue(json.contains("\"strict\":false"))
        // In non-strict mode, required should contain only the actually required keys
        XCTAssertTrue(json.contains("\"required\":[\"name\"]"))
        // Optional field should NOT admit null via union type
        XCTAssertFalse(json.contains("\"type\":[\"string\",\"null\"]"))
    }
}
