import SwiftSyntax
import Foundation
import SwiftSyntaxBuilder
import SwiftSyntaxMacros
import SwiftSyntaxMacrosTestSupport
import XCTest
import LLMToolSwift
import LLMToolOpenAI



struct MultipleToolsDispatcher {
    @LLMTool
    /**
     Summary line.

     - Parameter bar: your typical bar.
     */
    func foo(bar: String) {}

    @LLMTool
    /**
     Summary line.

     - Parameter pkao: your typical pkao.
     */
    func baz(pkao: Int) {}
}

// File-scope demo types for runtime macro expansion
// Runtime doc-block demo to validate real code (not string expansion)
struct DocRuntimeDemo {
    @LLMTool
    /**
     Summary line.

     - Parameter city: City name.
     */
    func f(city: String) {}
}

@LLMTools
struct Demo {
    enum E: String, CaseIterable { case a, b }
    /// Hi
    /// - Parameter name: Person name
    @LLMTool
    func hi(name: String) -> String { "Hi, \(name)" }
    /// Flag
    /// - Parameter on: Toggle value
    @LLMTool
    func flag(on: Bool) { _ = on }
}

// (llmTools and dispatcher generated by @LLMTools on the type)

// Additional demo to validate NSNull handling
@LLMTools
struct NullDemo {
    @LLMTool
    /// Test optional parameters become nil when NSNull is provided
    func optionalParams(a: String?, b: Int?) -> String {
        let aStr = a ?? "nil"
        let bStr = b.map(String.init) ?? "nil"
        return "\(aStr)-\(bStr)"
    }

    @LLMTool
    /// Test required parameter error when NSNull is provided
    func requiredParam(a: String) -> String { a }
}

// File-scope demo for filtering repository behavior
@LLMTools
struct FilterDemo {
    @LLMTool
    /// Hello
    /// - Parameter name: Name
    func hello(name: String) -> String { "Hi, \(name)" }
    @LLMTool
    /// Add
    /// - Parameter a: a
    /// - Parameter b: b
    func add(a: Int, b: Int) -> Int { a + b }
    @LLMTool
    /// Multiply
    /// - Parameter a: a
    /// - Parameter b: b
    func mul(a: Int, b: Int) -> Int { a * b }
}

// Macro implementations build for the host, so the corresponding module is not available when cross-compiling. Cross-compiled tests may still make use of the macro itself in end-to-end tests.
#if canImport(LLMToolSwiftMacros)
import LLMToolSwiftMacros

let testMacros: [String: Macro.Type] = [
    "stringify": StringifyMacro.self,
    "LLMTool": LLMToolMacro.self,
    "LLMTools": LLMToolsMacro.self,
]
#endif

final class LLMToolSwiftTests: XCTestCase {
    func testMacro() throws {
        #if canImport(LLMToolSwiftMacros)
        assertMacroExpansion(
            """
            #stringify(a + b)
            """,
            expandedSource: """
            (a + b, "a + b")
            """,
            macros: testMacros
        )
        #else
        throw XCTSkip("macros are only supported when running tests for the host platform")
        #endif
    }

    func testMacroWithStringLiteral() throws {
        #if canImport(LLMToolSwiftMacros)
        assertMacroExpansion(
            #"""
            #stringify("Hello, \(name)")
            """#,
            expandedSource: #"""
            ("Hello, \(name)", #""Hello, \(name)""#)
            """#,
            macros: testMacros
        )
        #else
        throw XCTSkip("macros are only supported when running tests for the host platform")
        #endif
    }

    func testLLMToolMacro_SimpleStringParam() throws {
        #if canImport(LLMToolSwiftMacros)
        assertMacroExpansion(
            """
            public struct S {
                /// Greeting
                /// - Parameter name: A name.
                @LLMTool
                public func f(name: String) {}
            }
            """,
            expandedSource: """
            public struct S {
                /// Greeting
                /// - Parameter name: A name.
                public func f(name: String) {}

                public static var fLLMTool: LLMTool {
                    LLMTool(
                        function: .init(
                            name: "f",
                            description: "Greeting",
                            parameters: .init(
                                properties: [
                                    "name": .init(
                                        type: "string",
                                        description: "A name.",
                                        enum: nil
                                    )
                                ],
                                required: ["name"]
                            )
                        )
                    )
                }
            }
            """,
            macros: testMacros
        )
        #else
        throw XCTSkip("macros are only supported when running tests for the host platform")
        #endif
    }

    func testLLMTools_RuntimeDispatcher() async throws {
        // Validate at runtime using file-scope Demo
        let d = Demo()
        XCTAssertEqual(d.llmTools.count, 2)
        let res = try await d.dispatchLLMTool(named: "hi", arguments: ["name": "Zed"]) as? String
        XCTAssertEqual(res, "Hi, Zed")
        do { _ = try await d.dispatchLLMTool(named: "hi", arguments: [:]); XCTFail("expected error") } catch {}
        do { _ = try await d.dispatchLLMTool(named: "unknown", arguments: [:]); XCTFail("expected error") } catch {}
    }

    func testLLMToolMacro_DocBlockParsing() throws {
        #if canImport(LLMToolSwiftMacros)
        assertMacroExpansion(
            """
            public struct S {
                @LLMTool
                /**
                 Summary line.
                 
                 - Parameter city: City name.
                 */
                public func f(city: String) {}
            }
            """,
            expandedSource: """
            public struct S {
                /**
                 Summary line.
                 
                 - Parameter city: City name.
                 */
                public func f(city: String) {}

                public static var fLLMTool: LLMTool {
                    LLMTool(
                        function: .init(
                            name: "f",
                            description: "Summary line.",
                            parameters: .init(
                                properties: [
                                    "city": .init(
                                        type: "string",
                                        description: "City name.",
                                        enum: nil
                                    )
                                ],
                                required: ["city"]
                            )
                        )
                    )
                }
            }
            """,
            macros: testMacros
        )
        #else
        throw XCTSkip("macros are only supported when running tests for the host platform")
        #endif
    }

    func testLLMTool_DocBlock_Runtime() throws {
        let tool = DocRuntimeDemo.fLLMTool
        XCTAssertEqual(tool.function.name, "f")
        XCTAssertEqual(tool.function.description, "Summary line.")
        XCTAssertEqual(tool.function.parameters.properties["city"]?.description, "City name.")
        XCTAssertEqual(tool.function.parameters.required, ["city"])
    }

    func testLLMTool_FunctionJSON_Shape() throws {
        let toolJSON = DocRuntimeDemo.fLLMTool.jsonString
        // Expect modern shape: no legacy wrapper, with strict and additionalProperties
        XCTAssertFalse(toolJSON.contains("\"type\":\"function\""))
        XCTAssertTrue(toolJSON.contains("\"strict\":true"))
        XCTAssertTrue(toolJSON.contains("\"additionalProperties\":false"))
        // Name should be snake_case of function name 'f' (same)
        XCTAssertTrue(toolJSON.contains("\"name\":\"f\""))
    }

    

    func testNSNullTreatedAsNilAndErrorForRequired() async throws {
        let d = NullDemo()
        // Optional params: NSNull should be treated as nil
        let r1 = try await d.dispatchLLMTool(named: "optionalParams", arguments: ["a": NSNull(), "b": NSNull()]) as? String
        XCTAssertEqual(r1, "nil-nil")
        let r2 = try await d.dispatchLLMTool(named: "optionalParams", arguments: ["a": "X", "b": NSNull()]) as? String
        XCTAssertEqual(r2, "X-nil")
        let r3 = try await d.dispatchLLMTool(named: "optionalParams", arguments: ["a": NSNull(), "b": 5]) as? String
        XCTAssertEqual(r3, "nil-5")

        // Required param: NSNull should be treated as missing
        do {
            _ = try await d.dispatchLLMTool(named: "requiredParam", arguments: ["a": NSNull()])
            XCTFail("expected missingArgument error for NSNull on required param")
        } catch LLMToolCallError.missingArgument(let name) {
            XCTAssertEqual(name, "a")
        } catch {
            XCTFail("unexpected error: \(error)")
        }
    }

    func testLLMTools_Filtering_Runtime() async throws {
        // File-scope annotated types conform to LLMToolsRepository
        let _: any LLMToolsRepository = FilterDemo()

        // Full repo has all three
        XCTAssertEqual(FilterDemo().llmTools.map { $0.function.name }, ["hello", "add", "mul"])

        let base = FilterDemo()
        let mask: FilterDemo.LLMToolFilterSet = [.hello, .add]
        let subset = base.filter(mask)

        // Subset lists only selected tools
        XCTAssertEqual(subset.llmTools.map { $0.function.name }, ["hello", "add"])

        // Allowed tools dispatch
        let r1 = try await subset.dispatchLLMTool(named: "hello", arguments: ["name": "Sam"]) as? String
        XCTAssertEqual(r1, "Hi, Sam")
        let r2 = try await subset.dispatchLLMTool(named: "add", arguments: ["a": 2, "b": 3]) as? Int
        XCTAssertEqual(r2, 5)

        // Disallowed tool throws same not-found error
        do {
            _ = try await subset.dispatchLLMTool(named: "mul", arguments: ["a": 2, "b": 3])
            XCTFail("expected functionNotFound for filtered-out tool")
        } catch LLMToolCallError.functionNotFound(let name) {
            XCTAssertEqual(name, "mul")
        } catch {
            XCTFail("unexpected error: \(error)")
        }
    }

    func testLLMTools_EmitsConformanceExtension_Expansion() throws {
        #if canImport(LLMToolSwiftMacros)
        assertMacroExpansion(
            """
            @LLMTools
            struct S {
                @LLMTool
                func f(a: Int) {}
            }
            """,
            expandedSource: """
            struct S {
                func f(a: Int) {}

                var llmTools: [LLMTool] {
                    [
                        Self.fLLMTool
                    ]
                }

                func dispatchLLMTool(named name: String, arguments: [String: Any]) async throws -> Any? {
                    switch name {
                    case "f":
                        guard let __v_a = arguments["a"] else { throw LLMToolCallError.missingArgument("a") }
                        if __v_a is NSNull { throw LLMToolCallError.missingArgument("a") }
                        guard let __i = __v_a as? Int else { throw LLMToolCallError.typeMismatch(param: "__arg_a", expected: "Int") }
                        let __arg_a = __i
                        return S.f(__arg_a)
                    default:
                        throw LLMToolCallError.functionNotFound(name)
                    }
                }

                struct LLMToolFilterSet: OptionSet {
                    let rawValue: UInt64
                    init(rawValue: UInt64) { self.rawValue = rawValue }
                    static let f = LLMToolFilterSet(rawValue: 1 << 0)
                    static let all: LLMToolFilterSet = [.f]
                }

                struct _FilteredRepository: LLMToolsRepository {
                    let base: S
                    let mask: LLMToolFilterSet

                    var llmTools: [LLMTool] { base.llmTools.filter { allows($0.function.name) } }

                    func dispatchLLMTool(named name: String, arguments: [String: Any]) async throws -> Any? {
                        guard allows(name) else { throw LLMToolCallError.functionNotFound(name) }
                        return try await base.dispatchLLMTool(named: name, arguments: arguments)
                    }

                    private func allows(_ name: String) -> Bool {
                        switch name {
                        case "f": return mask.contains(.f)
                        default: return false
                        }
                    }
                }

                func filter(_ set: LLMToolFilterSet) -> some LLMToolsRepository {
                    _FilteredRepository(base: self, mask: set)
                }
            }

            extension S: LLMToolsRepository {}
            """,
            macros: testMacros
        )
        #else
        throw XCTSkip("macros are only supported when running tests for the host platform")
        #endif
    }

    func testOpenAITool_StrictTrue_Encoding() throws {
        // Build a tool with one required and one optional param
        let params = LLMTool.Parameters(
            properties: [
                "name": .init(type: "string", description: "", enum: nil),
                "title": .init(type: "string", description: "", enum: nil)
            ],
            required: ["name"]
        )
        let tool = LLMTool(function: .init(name: "greet", description: "", parameters: params))

        let oaiTool = tool.openAITool(strict: true)
        let data = try JSONEncoder().encode(oaiTool)
        let json = String(data: data, encoding: .utf8) ?? ""
        XCTAssertTrue(json.contains("\"strict\":true"))
        // In strict mode, required should contain all properties
        XCTAssertTrue(json.contains("\"required\":[\"name\",\"title\"]"))
        // Optional field should admit null via union type
        XCTAssertTrue(json.contains("\"type\":[\"string\",\"null\"]"))
    }

    func testOpenAITool_StrictFalse_Encoding() throws {
        // Build a tool with one required and one optional param
        let params = LLMTool.Parameters(
            properties: [
                "name": .init(type: "string", description: "", enum: nil),
                "title": .init(type: "string", description: "", enum: nil)
            ],
            required: ["name"]
        )
        let tool = LLMTool(function: .init(name: "greet", description: "", parameters: params))

        let oaiTool = tool.openAITool(strict: false)
        let data = try JSONEncoder().encode(oaiTool)
        let json = String(data: data, encoding: .utf8) ?? ""
        XCTAssertTrue(json.contains("\"strict\":false"))
        // In non-strict mode, required should contain only the actually required keys
        XCTAssertTrue(json.contains("\"required\":[\"name\"]"))
        // Optional field should NOT admit null via union type
        XCTAssertFalse(json.contains("\"type\":[\"string\",\"null\"]"))
    }
}
