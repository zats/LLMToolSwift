import SwiftSyntax
import Foundation
import SwiftSyntaxBuilder
import SwiftSyntaxMacros
import SwiftSyntaxMacrosTestSupport
import XCTest
import LLMToolSwift
import LLMToolOpenAI
import LLMToolJSONSchema



struct MultipleToolsDispatcher {
    @LLMTool
    /**
     Summary line.

     - Parameter bar: your typical bar.
     */
    func foo(bar: String) {}

    @LLMTool
    /**
     Summary line.

     - Parameter pkao: your typical pkao.
     */
    func baz(pkao: Int) {}
}

// File-scope demo types for runtime macro expansion
// Runtime doc-block demo to validate real code (not string expansion)
struct DocRuntimeDemo {
    @LLMTool
    /**
     Summary line.

     - Parameter city: City name.
     */
    func f(city: String) {}
}

@LLMTools
struct Demo {
    enum E: String, CaseIterable { case a, b }
    /// Hi
    /// - Parameter name: Person name
    @LLMTool
    func hi(name: String) -> String { "Hi, \(name)" }
    /// Flag
    /// - Parameter on: Toggle value
    @LLMTool
    func flag(on: Bool) { _ = on }
}

// (llmTools and dispatcher generated by @LLMTools on the type)

// Additional demo to validate NSNull handling
@LLMTools
struct NullDemo {
    @LLMTool
    /// Test optional parameters become nil when NSNull is provided
    func optionalParams(a: String?, b: Int?) -> String {
        let aStr = a ?? "nil"
        let bStr = b.map(String.init) ?? "nil"
        return "\(aStr)-\(bStr)"
    }

    @LLMTool
    /// Test required parameter error when NSNull is provided
    func requiredParam(a: String) -> String { a }
}

// File-scope demo for filtering repository behavior
@LLMTools
struct FilterDemo {
    @LLMTool
    /// Hello
    /// - Parameter name: Name
    func hello(name: String) -> String { "Hi, \(name)" }
    @LLMTool
    /// Add
    /// - Parameter a: a
    /// - Parameter b: b
    func add(a: Int, b: Int) -> Int { a + b }
    @LLMTool
    /// Multiply
    /// - Parameter a: a
    /// - Parameter b: b
    func mul(a: Int, b: Int) -> Int { a * b }
}

// File-scope demo for static-only tool set
@LLMTools
struct StaticOnlyToolsFS {
    @LLMTool
    static func echo(text: String) -> String { text }
}

// Macro implementations build for the host, so the corresponding module is not available when cross-compiling. Cross-compiled tests may still make use of the macro itself in end-to-end tests.
#if canImport(LLMToolSwiftMacros)
import LLMToolSwiftMacros

let testMacros: [String: Macro.Type] = [
    "stringify": StringifyMacro.self,
    "LLMTool": LLMToolMacro.self,
    "LLMTools": LLMToolsMacro.self,
]
#endif

final class LLMToolSwiftTests: XCTestCase {
    func testMacro() throws {
        #if canImport(LLMToolSwiftMacros)
        assertMacroExpansion(
            """
            #stringify(a + b)
            """,
            expandedSource: """
            (a + b, "a + b")
            """,
            macros: testMacros
        )
        #else
        throw XCTSkip("macros are only supported when running tests for the host platform")
        #endif
    }

    func testMacroWithStringLiteral() throws {
        #if canImport(LLMToolSwiftMacros)
        assertMacroExpansion(
            #"""
            #stringify("Hello, \(name)")
            """#,
            expandedSource: #"""
            ("Hello, \(name)", #""Hello, \(name)""#)
            """#,
            macros: testMacros
        )
        #else
        throw XCTSkip("macros are only supported when running tests for the host platform")
        #endif
    }

    func testLLMToolMacro_SimpleStringParam() throws {
        #if canImport(LLMToolSwiftMacros)
        assertMacroExpansion(
            """
            public struct S {
                /// Greeting
                /// - Parameter name: A name.
                @LLMTool
                public func f(name: String) {}
            }
            """,
            expandedSource: """
            public struct S {
                /// Greeting
                /// - Parameter name: A name.
                public func f(name: String) {}

                public static var fLLMTool: LLMTool {
                    LLMTool(
                        function: .init(
                            name: "f",
                            description: "Greeting",
                            parameters: .init(
                                properties: [
                                    "name": .init(
                                        type: "string",
                                        description: "A name.",
                                        enum: nil
                                    )
                                ],
                                required: ["name"]
                            )
                        )
                    )
                }
            }
            """,
            macros: testMacros
        )
        #else
        throw XCTSkip("macros are only supported when running tests for the host platform")
        #endif
    }

    func testLLMTools_RuntimeDispatcher() async throws {
        // Validate at runtime using file-scope Demo
        let d = Demo()
        XCTAssertEqual(d.llmTools.count, 2)
        let res = try await d.dispatchLLMTool(named: "hi", arguments: ["name": "Zed"]) as? String
        XCTAssertEqual(res, "Hi, Zed")
        do { _ = try await d.dispatchLLMTool(named: "hi", arguments: [:]); XCTFail("expected error") } catch {}
        do { _ = try await d.dispatchLLMTool(named: "unknown", arguments: [:]); XCTFail("expected error") } catch {}
    }

    func testLLMToolMacro_DocBlockParsing() throws {
        #if canImport(LLMToolSwiftMacros)
        assertMacroExpansion(
            """
            public struct S {
                @LLMTool
                /**
                 Summary line.
                 
                 - Parameter city: City name.
                 */
                public func f(city: String) {}
            }
            """,
            expandedSource: """
            public struct S {
                /**
                 Summary line.
                 
                 - Parameter city: City name.
                 */
                public func f(city: String) {}

                public static var fLLMTool: LLMTool {
                    LLMTool(
                        function: .init(
                            name: "f",
                            description: "Summary line.",
                            parameters: .init(
                                properties: [
                                    "city": .init(
                                        type: "string",
                                        description: "City name.",
                                        enum: nil
                                    )
                                ],
                                required: ["city"]
                            )
                        )
                    )
                }
            }
            """,
            macros: testMacros
        )
        #else
        throw XCTSkip("macros are only supported when running tests for the host platform")
        #endif
    }

    func testLLMTool_DocBlock_Runtime() throws {
        let tool = DocRuntimeDemo.fLLMTool
        XCTAssertEqual(tool.function.name, "f")
        XCTAssertEqual(tool.function.description, "Summary line.")
        XCTAssertEqual(tool.function.parameters.properties["city"]?.description, "City name.")
        XCTAssertEqual(tool.function.parameters.required, ["city"])
    }

    func testLLMTool_FunctionJSON_Shape() throws {
        let toolJSON = DocRuntimeDemo.fLLMTool.jsonString
        // Expect modern shape: no legacy wrapper, with strict and additionalProperties
        XCTAssertFalse(toolJSON.contains("\"type\":\"function\""))
        XCTAssertTrue(toolJSON.contains("\"strict\":true"))
        XCTAssertTrue(toolJSON.contains("\"additionalProperties\":false"))
        // Name should be snake_case of function name 'f' (same)
        XCTAssertTrue(toolJSON.contains("\"name\":\"f\""))
    }

    

    func testNSNullTreatedAsNilAndErrorForRequired() async throws {
        let d = NullDemo()
        // Optional params: NSNull should be treated as nil
        let r1 = try await d.dispatchLLMTool(named: "optionalParams", arguments: ["a": NSNull(), "b": NSNull()]) as? String
        XCTAssertEqual(r1, "nil-nil")
        let r2 = try await d.dispatchLLMTool(named: "optionalParams", arguments: ["a": "X", "b": NSNull()]) as? String
        XCTAssertEqual(r2, "X-nil")
        let r3 = try await d.dispatchLLMTool(named: "optionalParams", arguments: ["a": NSNull(), "b": 5]) as? String
        XCTAssertEqual(r3, "nil-5")

        // Required param: NSNull should be treated as missing
        do {
            _ = try await d.dispatchLLMTool(named: "requiredParam", arguments: ["a": NSNull()])
            XCTFail("expected missingArgument error for NSNull on required param")
        } catch LLMToolCallError.missingArgument(let name) {
            XCTAssertEqual(name, "a")
        } catch {
            XCTFail("unexpected error: \(error)")
        }
    }

    func testLLMTools_Filtering_Runtime() async throws {
        // File-scope annotated types conform to LLMToolsRepository
        let _: any LLMToolsRepository = FilterDemo()

        // Full repo has all three
        XCTAssertEqual(FilterDemo().llmTools.map { $0.function.name }, ["hello", "add", "mul"])

        let base = FilterDemo()
        let mask: FilterDemo.LLMToolFilterSet = [.hello, .add]
        let subset = base.filter(mask)

        // Subset lists only selected tools
        XCTAssertEqual(subset.llmTools.map { $0.function.name }, ["hello", "add"])

        // Allowed tools dispatch
        let r1 = try await subset.dispatchLLMTool(named: "hello", arguments: ["name": "Sam"]) as? String
        XCTAssertEqual(r1, "Hi, Sam")
        let r2 = try await subset.dispatchLLMTool(named: "add", arguments: ["a": 2, "b": 3]) as? Int
        XCTAssertEqual(r2, 5)

        // Disallowed tool throws same not-found error
        do {
            _ = try await subset.dispatchLLMTool(named: "mul", arguments: ["a": 2, "b": 3])
            XCTFail("expected functionNotFound for filtered-out tool")
        } catch LLMToolCallError.functionNotFound(let name) {
            XCTAssertEqual(name, "mul")
        } catch {
            XCTFail("unexpected error: \(error)")
        }
    }

    // Note: We rely on runtime conformance checks rather than exact string
    // matching for the extension emission, to avoid overfitting formatting.

    func testOpenAITool_StrictTrue_Encoding() throws {
        // Build a tool with one required and one optional param
        let params = LLMTool.Parameters(
            properties: [
                "name": .init(type: "string", description: "Full name", enum: nil),
                "title": .init(type: "string", description: "Honorific title", enum: nil)
            ],
            required: ["name"]
        )
        let tool = LLMTool(function: .init(name: "greet", description: "", parameters: params))

        let oaiTool = tool.openAITool(strict: true)
        let data = try JSONEncoder().encode(oaiTool)
        let json = String(data: data, encoding: .utf8) ?? ""
        XCTAssertTrue(json.contains("\"strict\":true"))
        // In strict mode, required should contain all properties
        XCTAssertTrue(json.contains("\"required\":[\"name\",\"title\"]"))
        // Optional field should admit null via union type
        XCTAssertTrue(json.contains("\"type\":[\"string\",\"null\"]"))
        // Parameter descriptions should be present
        XCTAssertTrue(json.contains("\"description\":\"Full name\""))
        XCTAssertTrue(json.contains("\"description\":\"Honorific title\""))
    }

    func testOpenAITool_StrictFalse_Encoding() throws {
        // Build a tool with one required and one optional param
        let params = LLMTool.Parameters(
            properties: [
                "name": .init(type: "string", description: "Full name", enum: nil),
                "title": .init(type: "string", description: "Honorific title", enum: nil)
            ],
            required: ["name"]
        )
        let tool = LLMTool(function: .init(name: "greet", description: "", parameters: params))

        let oaiTool = tool.openAITool(strict: false)
        let data = try JSONEncoder().encode(oaiTool)
        let json = String(data: data, encoding: .utf8) ?? ""
        XCTAssertTrue(json.contains("\"strict\":false"))
        // In non-strict mode, required should contain only the actually required keys
        XCTAssertTrue(json.contains("\"required\":[\"name\"]"))
        // Optional field should NOT admit null via union type
        XCTAssertFalse(json.contains("\"type\":[\"string\",\"null\"]"))
        // Parameter descriptions should be present
        XCTAssertTrue(json.contains("\"description\":\"Full name\""))
        XCTAssertTrue(json.contains("\"description\":\"Honorific title\""))
    }

    func testJSONSchema_StrictTrue() throws {
        let params = LLMTool.Parameters(
            properties: [
                "name": .init(type: "string", description: "Full name", enum: nil),
                "title": .init(type: "string", description: "Honorific title", enum: nil)
            ],
            required: ["name"]
        )
        let tool = LLMTool(function: .init(name: "greet", description: "", parameters: params))
        let json = tool.jsonSchema(strict: true)
        XCTAssertTrue(json.contains("\"type\":\"object\""))
        XCTAssertTrue(json.contains("\"required\":[\"name\",\"title\"]"))
        XCTAssertTrue(json.contains("\"additionalProperties\":false"))
        XCTAssertTrue(json.contains("\"type\":[\"string\",\"null\"]"))
        XCTAssertTrue(json.contains("\"strict\":true"))
        // Parameter descriptions should be present
        XCTAssertTrue(json.contains("\"description\":\"Full name\""))
        XCTAssertTrue(json.contains("\"description\":\"Honorific title\""))
    }

    func testJSONSchema_StrictFalse() throws {
        let params = LLMTool.Parameters(
            properties: [
                "name": .init(type: "string", description: "Full name", enum: nil),
                "title": .init(type: "string", description: "Honorific title", enum: nil)
            ],
            required: ["name"]
        )
        let tool = LLMTool(function: .init(name: "greet", description: "", parameters: params))
        let json = tool.jsonSchema(strict: false)
        XCTAssertTrue(json.contains("\"required\":[\"name\"]"))
        XCTAssertFalse(json.contains("\"type\":[\"string\",\"null\"]"))
        XCTAssertTrue(json.contains("\"strict\":false"))
        // Parameter descriptions should be present
        XCTAssertTrue(json.contains("\"description\":\"Full name\""))
        XCTAssertTrue(json.contains("\"description\":\"Honorific title\""))
    }

    func testJSONSchema_StringVariant() throws {
        let params = LLMTool.Parameters(
            properties: [
                "name": .init(type: "string", description: "Full name", enum: nil),
                "title": .init(type: "string", description: "Honorific title", enum: nil)
            ],
            required: ["name"]
        )
        let tool = LLMTool(function: .init(name: "greet", description: "", parameters: params))
        let json = tool.jsonSchema(strict: true)
        XCTAssertTrue(json.contains("\"required\":[\"name\",\"title\"]"))
        XCTAssertTrue(json.contains("\"strict\":true"))
        XCTAssertTrue(json.contains("\"description\":\"Full name\""))
        XCTAssertTrue(json.contains("\"description\":\"Honorific title\""))
    }

    func testLLMTools_StaticOnly_ConformanceAndDispatch() async throws {
        // Conformance must be satisfied even if all tools are static
        let repo: any LLMToolsRepository = StaticOnlyToolsFS()
        XCTAssertEqual(repo.llmTools.map { $0.function.name }, ["echo"])
        let r = try await repo.dispatchLLMTool(named: "echo", arguments: ["text": "OK"]) as? String
        XCTAssertEqual(r, "OK")
    }
}
